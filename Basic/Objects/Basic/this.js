/*
		this

			Методы внутри оъекта могут сслаться на сам объект через this:
				obj = {
						name: 'Ivan',
						sayHello ()
						{
								console.log('hello, Im '+ this.name);
						}
				}

				При этом:
						obj.sayHello - вернет специальное значение - ReferenceType (внутренний тип)
						obj.sayHello() - вызовет функцию (скобки ()- применяются к значению ссылочногот типа и передают всю инфу)

				Состав ReferenceType:
	    			base – это объект.
	    			name – это имя свойства объекта.
	    			strict – это режим исполнения. Является true, если действует строгий режим (use strict).
 

			this - НЕ ФИКСИРОВАННЫЙ

				В отличии от других языков программрования, где this является постоянным 
				указателем на объект, this JS внутри функции просчитывается в тот момент, 
				когда функция будет вызвана, это дает новые возможности использования:
*/

				let user = { name: "Джон" };
				let admin = { name: "Админ" };

				function sayHi() {
				  alert( this.name );
				}

				// используем одну и ту же функцию в двух объектах
				user.f = sayHi;
				admin.f = sayHi;

				// вызовы функции, приведённые ниже, имеют разное значение this
				// "this" внутри функции является ссылкой на объект, который указан "перед точкой"
				user.f(); // Джон  (this == user)
				admin.f(); // Админ  (this == admin)

 
 /*
		У стрелочных функций нет this

				Если использовать this в стрелочной функции, то this будет указывать на внешнюю функцию:

 */

		 let user = {
		  firstName: "Илья",
		  sayHi() {
		    let arrow = () => alert(this.firstName);
		    arrow();
		  }
		};

		user.sayHi(); // Илья