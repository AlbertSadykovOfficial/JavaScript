/*
			
			Proxy

					Proxy - "посредник передачи". 

					{
							Это я не совсем понял, так что лучше почитать где-нибудь еще.

							Проки и декораторы - моя логика на данный момент:
									Они по логике похожи на декораторы, но отличаются от них, вроде, вробросом параметров,
									т.е Proxy как бы невидимы и функция считает, что обратилась напрямую, без посредников
					}

					Прокси – это обёртка вокруг объекта, которая «по умолчанию» перенаправляет операции над ней на объект, но имеет возможность перехватывать их.
					Проксировать можно любой объект, включая классы и функции.

					Синтаксис:

							let proxy = new Proxy(target, {
							  /* ловушки * /
							});

							…Затем обычно используют прокси везде вместо оригинального объекта target.
							При этом все значения будут обработаны proxy и помещены в target, поэтому target изменится.


					JavaScript налагает некоторые условия – инварианты на реализацию внутренних методов и ловушек.

							Большинство из них касаются возвращаемых значений:

							    Метод [[Set]] должен возвращать true, если значение было успешно записано, иначе false.
							    Метод [[Delete]] должен возвращать true, если значение было успешно удалено, иначе false.
							    …и так далее, мы увидим больше в примерах ниже.

				
					Прокси не имеет собственных свойств или методов. Он просто перехватывает операцию, если имеется соответствующая ловушка, 
					а иначе перенаправляет её сразу на объект target.

					Мы можем перехватывать:

					    Чтение (get), запись (set), удаление (deleteProperty) свойства (даже несуществующего).
					    Вызов функции (apply).
					    Оператор new (ловушка construct).
					    И многие другие операции (полный список приведён в начале статьи, а также в документации).

							Это позволяет нам создавать «виртуальные» свойства и методы, реализовывать значения по умолчанию, наблюдаемые объекты, 
							функции-декораторы и многое другое.
							Мы также можем оборачивать один и тот же объект много раз в разные прокси, добавляя ему различные аспекты функциональности.


					Reflect API создано как дополнение к Proxy. 

							Reflect – встроенный объект, упрощающий создание прокси.

							Для любой ловушки из Proxy существует метод в Reflect с теми же аргументами. 
							Нам следует использовать его, если нужно перенаправить вызов на оригинальный объект.


					Прокси имеют некоторые ограничения:

					    1) Встроенные объекты используют так называемые «внутренние слоты», доступ к которым нельзя проксировать. 
					    	 Однако, ранее в этой главе был показан один способ, как обойти это ограничение.
					    2) То же самое можно сказать и о приватных полях классов, так как они реализованы на основе слотов. 
					    	 То есть вызовы проксированных методов должны иметь оригинальный объект в качестве this, чтобы получить к ним доступ.
					    3) Проверка объектов на строгое равенство === не может быть перехвачена.
					    4) Производительность: конкретные показатели зависят от интерпретатора, 
					    	 но в целом получение свойства с помощью простейшего прокси занимает в несколько раз больше времени. 
					    	 В реальности это имеет значение только для некоторых «особо нагруженных» объектов


*/


// Пример - если элемента в массиве нет, вернуть - 0
		let numbers = [0, 1, 2];

		numbers = new Proxy(numbers, {
		  get(target, prop) {
		    if (prop in target) {
		      return target[prop];
		    } else {
		      return 0; // значение по умолчанию
		    }
		  }
		});

		alert( numbers[1] ); // 1
		alert( numbers[123] ); // 0 (нет такого элемента)


// Пример - вернуть фразу, если для нее нет перевода
		let dictionary = {
		  'Hello': 'Hola',
		  'Bye': 'Adiós'
		};

		dictionary = new Proxy(dictionary, {
		  get(target, phrase) { // перехватываем чтение свойства в dictionary
		    if (phrase in target) { // если перевод для фразы есть в словаре
		      return target[phrase]; // возвращаем его
		    } else {
		      // иначе возвращаем непереведённую фразу
		      return phrase;
		    }
		  }
		});

		// Запросим перевод произвольного выражения в словаре!
		// В худшем случае оно не будет переведено
		alert( dictionary['Hello'] ); // Hola
		alert( dictionary['Welcome to Proxy']); // Welcome to Proxy (нет перевода)