/*
		
		Клонирование и копирование объектов

			Объекты в отличии от переменных хранят ссылку на ячейку адреса памяти, поэтому
			если мы создали новый объект и присвоили в него другой объект, то присвоили не
			содержимое объекта, а ссылку на объект. Это значит, что мы получим 2 разных 
			укзаателя на Один объект, а не 2 одинаковых объекта.

*/
		let obj = {'name':'Dima'}
		let new_obj = {};
		new_obj = obj;
		
		new_obj['name'] = 'Ivan'
		console.log(obj['name']) // Ivan

		console.log(obj == new_obj) // true - это 2 одинаковые ссылки на 1 объект.

/*
		
		Чтобы все же склонировть объект, нужно поступить другим образом, есть 3 варианта:
			1) Написать функцию копирования по ключам
			2) Использовать специальную фунцию клонирования Object.assign

			Object.assign:
					
					Object.assign(dest, [src1, src2, src3...])

						dest - целевой объект, куда будут скопированы все свойсва из объектов srcN
						srcN - объекты, свосва которых нужо скопировать.

					При этом, если свойства повторяются, то будет записано последнее значение.

*/
		// 1-вариант

				let user = {
				  name: "Иван",
				  age: 30
				};

				let clone = {}; // новый пустой объект

				// скопируем все свойства user в него
				for (let key in user) {
				  clone[key] = user[key];
				}

		// 2 - вариант

				let permissions1 = { canView: true };
				let permissions2 = { canEdit: true };
				
				Object.assign(user, permissions1, permissions2);
				let clone = Object.assign({}, user);

/*
		Вложенное клонирование.

			Вложенное клонирование подразумевает правильное клонирование, даже если внтури клонируемого объекта
			есть другие объекты. 
			Проблема такого клонирования в том, что если есть вложенный объект, то опять же будет скопирована его
			ссылка, а не он сам, чтобы избежать этого, нужно использовтаь специальные функции или писать свои. 

			1) Написать функцию копирования по ключам с обработкой вложенных объектов
			2) Использовать специальную фунцию клонирования _.cloneDeep(obj) из JavaScript-библиотеки lodash.
*/