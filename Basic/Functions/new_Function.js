/*

		Синтаксис new Function

				Функцию можно создать налету, для этого используют синтаксис new Function,
				при этом сама функция передается в виде строки содердимого.:

						let sum = new Function('a', 'b', 'return a + b');

						или
								new Function('a,b', 'return a + b'); // через запятую в одной строке
								new Function('a , b', 'return a + b'); // через запятую с пробелами в одной строке

				Синтаксис:

						let func = new Function([arg1, arg2, ...argN], functionBody);


				Особенности:

				Замыкание

						* Функция new Function знает только глобальные переменные

						Обычно функция запоминает, где родилась, в специальном свойстве [[Environment]]. 
						Это ссылка на лексическое окружение (Lexical Environment), в котором она создана (мы разбирали это в главе Замыкание).

						Но когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в
						котором она была создана, а на глобальное. Поэтому такая функция имеет доступ только к глобальным переменным.


*/

/*
		Пример - функция new Function знает только глобальные переменные

				Эта особенность new Function выглядит странно, но оказывается очень полезной на практике.

				Представьте, что нужно создать функцию из строки. Код этой функции неизвестен во время написания скрипта (поэтому не используем обычные функции), 
				а будет определён только в процессе выполнения. Мы можем получить код с сервера или с другого ресурса.
				Наша новая функция должна взаимодействовать с основным скриптом.

				Что если бы она имела доступ к внешним переменным?
				Проблема в том, что перед отправкой JavaScript-кода на реальные работающие проекты код сжимается с помощью минификатора – специальной программы, 
				которая уменьшает размер кода, удаляя комментарии, лишние пробелы, и, что самое главное, локальным переменным даются укороченные имена.
				Например, если в функции объявляется переменная let userName, то минификатор изменяет её на let a (или другую букву, если она не занята) 
				и изменяет её везде. Обычно так делать безопасно, потому что переменная является локальной, и никто снаружи не имеет к ней доступ. 
				И внутри функции минификатор заменяет каждое её упоминание. Минификаторы достаточно умные. 
				Они не просто осуществляют «тупой» поиск-замену, они анализируют структуру кода, и поэтому ничего не ломается.

				Так что если бы даже new Function и имела доступ к внешним переменным, она не смогла бы найти переименованную userName.
*/

function getFunc() {
  let value = "test";

  let func = new Function('alert(value)');

  return func;
}