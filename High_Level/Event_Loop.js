/*
		
		Событийый цикл

				Немного греческого:
						мАкро - большой, длиный 
						мИкро - маленький

				Упрощенный алгоритм событийного цикла:

				   1) Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
				   2) Исполнить все микрозадачи:
				       	2.1. Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
				   3) Отрисовать изменения страницы, если они есть.
				   4) Если очередь макрозадач пуста – подождать, пока появится макрозадача.
				   5) Перейти к шагу 1.
				

				Разбиение сложных-длительных задач
						
						Допустим, у нас есть задача, требующая значительных ресурсов процессора.

						Вспомним: JS однопоточный, он выполняет задачи в 1 поток по мере их поступления.

						Если мы дадим такую задачу Движку JS на обработку, то он встанет на ее выполнении,
						потому что будет выполняться микрозадача. А отрисовка проиходит после МИКРОзадачи,
						а значит страница подвиснет на время выполнения.

						Решение:
								Мы можем избежать этого, разбив задачу на части, к прмиеру использовав setTimeout рекурсивно.

						НО как это работает?
								Алгоритм:
										1) Сделать рекурсивный вызов setTimeout, где она СНАЧАЛА - посчитает, потом Вызовет саму себя
										2) Пока идет подсчет, добавить в очередь другую задачу.

								Пример:
										Когда мы 1й раз вызовем setTimeout, то она встанет в очередь, затем вызовется и начнет выполняться,
										ЕСЛИ мы во время выполнения добавим другую задачу (X) в очередь, то она будет 1й в очереди.
										ТОГДА: по завершении расчета setTimeout снова вызовется рекурсивно - вставит в очередь саму себя.
										НО первым в очереди будет задач (X), а поэтому выполнится она, setTimeout будет 2й в очереди.
										ЗАТЕМ, после завершения (X), будет сноава выполняться фукция ИЗ setTimeout, которая станет 1й в очереди.
						

				
				Очередность МИКРО и МАКРО-задач:

						Сразу после каждой мАкрозадачи движок исполняет все задачи из очереди мИкрозадач перед тем, 
						как выполнить следующую мАкрозадачу или отобразить изменения на странице, или сделать что-то ещё.

				
				Добавление в очердь МАКРОзадач:

				 		setTimeout(f) с нулевой задержкой.

				 		* Примечание: 0 задержки в JS нет, будет автоматичеки задержка в 4мс
				
				Добавление в очередб МИКРОзадач:

						1) queueMicrotask(f)
						2) Или обработчики Promise - они выполняются в рамках очереди микрозадач.

						События пользовательского интерфейса и сетевые события в промежутках между микрозадачами не обрабатываются: 
						микрозадачи исполняются непрерывно одна за другой.
						Поэтому queueMicrotask можно использовать для асинхронного выполнения функции в том же состоянии окружения.


*/

		// Пример - что выполнится быстрее

				setTimeout(() => alert("timeout"));

				Promise.resolve()
				  .then(() => alert("promise"));

				alert("code");
				
				/* Ответ:
				*		code, promise, timeout
				*		Потому что :
				*		   1) code появляется первым, т.к. это обычный синхронный вызов.
				*		   2) promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
				*		   3) timeout появляется последним, потому что это макрозадача.
				*
				*/


		// Пример - разбиение тяжелой задачи:

				// Вариант 1. Без разбиения - удачи, жди пока все выполнится, если запустишь
						let i = 0;

						let start = Date.now();

						function count() 
						{
							  // делаем тяжёлую работу
							  for (let j = 0; j < 1e8; j++) {
							    	i++;
							  }

							  alert("Done in " + (Date.now() - start) + 'ms');
						}

						count();

				// Вариант 2. С разбиением - бразуер может "дышать".

						let i = 0;

						let start = Date.now();

						function count() 
						{

							  // перенесём планирование очередного вызова в начало
							  if (i < 1e9 - 1e6) {
							    	setTimeout(count); // запланировать новый вызов
							  }

							  do {
							    	i++;
							  } while (i % 1e6 != 0);

							  if (i == 1e9) {
							    	alert("Done in " + (Date.now() - start) + 'ms');
							  }

						}

						count();



		/* Пример 3  - statusBar

					<div id="progress"></div>

					<script>
					  let i = 0;

					  function count() {

					    // сделать часть крупной задачи (*)
					    do {
					      i++;
					      progress.innerHTML = i;
					    } while (i % 1e3 != 0);

					    if (i < 1e7) {
					      setTimeout(count);
					    }

					  }

					  count();
					</script>

		*/